:coffee:

### Usage With React

Form the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, vanilla JavaScript.

That said, Redux works especially will with libraries like React because they let you describe UI as a function of state, and Redux emits state updates in response to actions.

### Installing React Redux

```js
npm install --save react-redux
```

### Presentational and Container Components

React bindings for Redux separate _presentational_ components from _container_ components. This approach can make your app easier to understand and allow you to more easily reuse components. :zap: Here's a summary of the differences between presentational and container components.

:black_heart: [Presentational and Container Components by Dan Abramov][1]

|                    | Presentational Components       | Container Components                          |
| ------------------ | ------------------------------- | --------------------------------------------- |
| **Purpose**        | How things look(markup, styles) | How things work(data fetching, state updates) |
| **Aware of Redux** | No                              | Yes                                           |
| **To read data**   | Read data from props            | Subscribe to Redux state                      |
| **To change data** | Invoke callbacks from props     | Dispatch Redux actions                        |
| **Are written**    | By hand                         | Usually generated by React Redux              |

### Designing Presentational Components

The following are the presentational components and their props for todo app:

- **TodoList** is a list showing visible todos.

  - `todos: Array` is an array todo items with `{ id, text, completed}` shape.
  - `onTodoClick(id: number)` is callback to invoke when a todo is clicked.

- **Todo** is a single todo item.

  - `text: string` is the text to show.
  - `completed: boolean` is whether the todo should appear crossed out.
  - `onClick()` is a callback to invoke when the todo is clicked.

- **Link** is a link with a callback.

  - `onClick()` is a callback to invoke when the link is clicked.

- **Footer** is where we let the user change currently visible todos.

- **App** is the root component that renders everything else.

They describe the _look_ but don't know _where_ the data come from, or _how_ to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.

### Designing Container Components

We will also need some container components to connect the presentational components to Redux. For example the presentational `TodoList` component needs a container like `VisibleTodoList` that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a `FilterLink` container component that renders a `Link` that dispatches an appropriate action on click:

- **VisibleTodoList** filters the todos according to current visibility filter and renders a `TodoList`.

- **FilterLink** gets the current visibility filter and renders a `Link`.
  - `filter: string` is the visibility filter it represents.

### Designing Other Components

Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are easily coupled together, such as in the case this tiny component:

- **AddTodo** is an input field with an "Add" button

Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small, As it grows, it will be more obvious how to split it, so we'll leave it mixed.

### Implementing Presentational Components

These are all normal React components. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components _have_ to be functional optimizations, you can convert them to classes.

components/Todo.js

```js
import React from "react";
import PropTypes from "prop-types";

const Todo = ({ onClick, completed, text }) => (
  <li
    onClick={onClick}
    style={{
      textDecoration: completed ? "line-through" : "none"
    }}
  >
    {text}
  </li>
);

Todo.propTypes = {
  onClick: PropTypes.func.isRequired,
  completed: PropTypes.bool.isRequired,
  text: PropTypes.string.isRequired
};

export default Todo;
```

components/TodoList.js

```js
import React from "react";
import PropTypes from "prop-types";
import Todo from "./Todo";

const TodoList = ({ todos, onTodoClick }) => (
  <ul>
    {todos.map((todo, index) => (
      <Todo key={index} {...todo} onClick={() => onTodoClick(index)} />
    ))}
  </ul>
);

TodoList.propTypes = {
  todos: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.number.isRequired,
      completed: PropTypes.bool.isRequired,
      text: PropTypes.string.isRequired
    }).isRequired
  ).isRequired,
  onTodoClick: PropTypes.func.isRequired
};

export default TodoList;
```

components/Link.js

```js
import React from "react";
import PropTypes from "prop-types";

const Link = ({ active, children, onClick }) => {
  if (active) {
    return <span>{children}</span>;
  }

  return (
    <a
      href=""
      onClick={e => {
        e.preventDefault();
        onClick();
      }}
    >
      {children}
    </a>
  );
};

Link.propTypes = {
  active: PropTypes.bool.isRequired,
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func.isRequired
};

export default Link;
```

components/Footer.js

```js
import React from "react";
import FilterLink from "../containers/FilterLink";
import { VisibilityFilters } from "../actions";

const Footer = () => (
  <p>
    Show: <FilterLink filter={VisibilityFilters.SHOW_ALL}>All</FilterLink>
    {", "}
    <FilterLink filter={VisibilityFilters.SHOW_ACTIVE}>Active</FilterLink>
    {", "}
    <FilterLink filter={VisibilityFilters.SHOW_COMPLETED}>Completed</FilterLink>
  </p>
);

export default Footer;
```

### Implementing Container Components

Now it's time to hook up these presentational components to Redux by creating some containers. Technically, a container component is just React component that uses `store.dispatch()` to read part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with React Redux library's `connect()` function, which provides many useful optimizations to prevent unnecessary re-renders.

To use `connect()`, you need to define a special function called `mapStateToProps()` that describes how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, `VisibleTodoList` needs to calculate `todos` to pass the `TodoList`, so we define a function that filters that the `state.todos` according to the `state.visibilityFilter` and use it in its `mapStateToProps`:

```js
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case "SHOW_COMPLETED":
      return todos.filter(t => t.completed);
    case "SHOW_ACTIVE":
      return todos.filter(t => !t.completed);
    case "SHOW_ALL":
    default:
      return todos;
  }
};

const mapStateToProps = state => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  };
};
```

In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called `mapDispatchToProps()` that receives the `dispatch()` method and returns callback props that you want to inject into the presentational component. For example, we want the `VisibleTodoList` to inject a prop called `onTodoClick` into the `TodoList` component, and we want `onTodoClick` to dispatch a `TOGGLE_TODO` action:

```js
const mapDispatchToProps = dispatch => {
  return {
    onTodoClick: id => {
      dispatch(toggleTodo(id));
    }
  };
};
```

Finally, we create the `VisibleTodoList` by calling `connect()` and passing these two function:

```js
import { connect } from "react-redux";

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList);

export default VisibleTodoList;
```

These are the basics of React Redux API.

containers/FilterLink.js

```js
import { connect } from "react-redux";
import { setVisibilityFilter } from "../actions";
import Link from "../components/Link";

const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  };
};

const mapDispatchToProps = (dispatch, ownProps) => {
  return {
    onClick: () => {
      dispatch(setVisibilityFilter(ownProps.filter));
    }
  };
};

const FilterLink = connect(
  mapStateToProps,
  mapDispatchToProps
)(Link);

export default FilterLink;
```

containers/VisibleTodoList.js

```js
import { connect } from "react-redux";
import { toggleTodo } from "../actions";
import TodoList from "../components/TodoList";

const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case "SHOW_ALL":
      return todos;
    case "SHOW_COMPLETED":
      return todos.filter(t => t.completed);
    case "SHOW_ACTIVE":
      return todos.filter(t => !t.completed);
  }
};

const mapStateToProps = state => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  };
};

const mapDispatchToProps = dispatch => {
  return {
    onTodoClick: id => {
      dispatch(toggleTodo(id));
    }
  };
};

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList);

export default VisibleTodoList;
```

### Implementing Other Components

containers/AddTodo.js

Recall as mentioned previously, both the presentation and logic for the AddTodo component are mixed into a single definition.

```js
import React from "react";
import { connect } from "react-redux";
import { addTodo } from "../actions";

let AddTodo = ({ dispatch }) => {
  let input;

  return (
    <div>
      <form
        onSubmit={e => {
          e.preventDefault();
          if (!input.value.trim()) {
            return;
          }
          dispatch(addTodo(input.value));
          input.value = "";
        }}
      >
        <input
          ref={node => {
            input = node;
          }}
        />
        <button type="submit">Add Todo</button>
      </form>
    </div>
  );
};
AddTodo = connect()(AddTodo);

export default AddTodo;
```

container/App.js

```js
import React from "react";
import Footer from "./Footer";
import AddTodo from "../containers/AddTodo";
import VisibleTodoList from "../containers/VisibleTodoList";

const App = () => (
  <div>
    <AddTodo />
    <VisibleTodoList />
    <Footer />
  </div>
);

export default App;
```

### Passing the Store

All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as props to every container container. However it gets tedious, as you have to wire `store` even though presentational containers just because they happen to render a container deep in the component tree.

index.js

```js
import React from "react";
import { render } from "react-dom";
import { Provider } from "react-redux";
import { createStore } from "redux";
import todoApp from "./reducers";
import App from "./components/App";

const store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);
```

[1]: https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0
